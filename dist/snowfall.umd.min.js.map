{"version":3,"file":"snowfall.umd.min.js","sources":["../src/snowflake.js","../src/index.js"],"sourcesContent":["export class Snowflake {\n    constructor(x, y, radius, speed, wind, color = 'white') {\n        // Store initial properties for reuse\n        this.initialX = x;\n        this.initialRadius = radius;\n        this.initialSpeed = speed;\n        this.color = color;\n        \n        // Current state\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.speed = speed;\n        this.wind = wind;\n        this.isReset = false;\n    }\n\n    update(canvasHeight, wind) {\n        this.y += this.speed;\n        this.x += wind;\n\n        // Simple bounds check\n        this.isReset = this.y > canvasHeight + this.radius * 2;\n    }\n\n    draw(ctx) {\n        // Skip drawing if offscreen\n        if (this.y < -this.radius * 2) return;\n        \n        // Use optimized circle drawing\n        ctx.beginPath();\n        ctx.arc(this.x | 0, this.y | 0, this.radius, 0, 6.283); // 6.283 â‰ˆ 2 * Math.PI, avoid calculation\n        ctx.fillStyle = this.color;\n        ctx.fill();\n    }\n\n    reset(x, y) {\n        this.x = x;\n        this.y = y;\n        this.isReset = false;\n    }\n}","import { Snowflake } from './snowflake';\n\nclass SnowfallCanvas {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d', { alpha: true }); // Enable transparent background\n        \n        // Default options\n        this.options = {\n            count: options.count || 100,\n            minRadius: options.minRadius || 2,\n            maxRadius: options.maxRadius || 5,\n            minSpeed: options.minSpeed || 1,\n            maxSpeed: options.maxSpeed || 3,\n            wind: options.wind || 0,\n            color: options.color || 'white',\n            opacity: options.opacity || 0.8,\n            ...options\n        };\n\n        this.snowflakes = new Array(this.options.count); // Pre-allocate array\n        this.isRunning = false;\n        this.animationFrame = null;\n        this.lastTime = 0;\n        this.frameInterval = 1000 / 60; // Target 60 FPS\n\n        // Bind methods that are used in animation loop\n        this.animate = this.animate.bind(this);\n\n        // Initialize after setting canvas dimensions\n        this.resize();\n        this.init();\n\n        // Debounced resize handler\n        let resizeTimeout;\n        window.addEventListener('resize', () => {\n            if (resizeTimeout) clearTimeout(resizeTimeout);\n            resizeTimeout = setTimeout(() => {\n                this.resize();\n                // Redistribute snowflakes across the new canvas width\n                const width = this.canvas.width;\n                this.snowflakes.forEach(snowflake => {\n                    snowflake.x = Math.random() * width;\n                });\n            }, 150);\n        });\n    }\n\n    init() {\n        const { width, height } = this.canvas;\n        \n        // Create snowflakes in a single loop\n        for (let i = 0; i < this.options.count; i++) {\n            const x = Math.random() * width;\n            const y = Math.random() * height - height; // Start above the canvas\n            this.snowflakes[i] = this.createSnowflake(x, y);\n        }\n    }\n\n    createSnowflake(x = null, y = null) {\n        const { minRadius, maxRadius, minSpeed, maxSpeed, wind, color } = this.options;\n        \n        const radius = Math.random() * (maxRadius - minRadius) + minRadius;\n        // Calculate speed based on radius - bigger snowflakes fall faster\n        const radiusRatio = (radius - minRadius) / (maxRadius - minRadius);\n        const speed = minSpeed + (maxSpeed - minSpeed) * radiusRatio;\n        \n        x = x ?? Math.random() * this.canvas.width;\n        y = y ?? Math.random() * -this.canvas.height;\n\n        return new Snowflake(x, y, radius, speed, wind, color);\n    }\n\n    resize() {\n        const { offsetWidth, offsetHeight } = this.canvas;\n        this.canvas.width = offsetWidth;\n        this.canvas.height = offsetHeight;\n        \n        // Set constant properties\n        this.ctx.fillStyle = 'white';\n    }\n\n    start() {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            this.lastTime = performance.now();\n            this.animate();\n        }\n    }\n\n    stop() {\n        this.isRunning = false;\n        if (this.animationFrame) {\n            cancelAnimationFrame(this.animationFrame);\n            this.animationFrame = null;\n        }\n    }\n\n    animate(currentTime = 0) {\n        if (!this.isRunning) return;\n\n        // Control frame rate\n        const elapsed = currentTime - this.lastTime;\n        if (elapsed < this.frameInterval) {\n            this.animationFrame = requestAnimationFrame(this.animate);\n            return;\n        }\n        this.lastTime = currentTime - (elapsed % this.frameInterval);\n\n        const { width, height } = this.canvas;\n        const { wind } = this.options;\n        \n        this.ctx.clearRect(0, 0, width, height);\n        \n        // Update and draw in a single loop\n        for (let i = 0; i < this.snowflakes.length; i++) {\n            const snowflake = this.snowflakes[i];\n            snowflake.update(height, wind);\n            \n            if (snowflake.isReset) {\n                const x = Math.random() * width;\n                // When resetting, recalculate speed based on radius\n                const radiusRatio = (snowflake.radius - this.options.minRadius) / (this.options.maxRadius - this.options.minRadius);\n                snowflake.speed = this.options.minSpeed + (this.options.maxSpeed - this.options.minSpeed) * radiusRatio;\n                snowflake.wind = wind;\n                snowflake.reset(x, -10);\n            }\n            \n            snowflake.draw(this.ctx);\n        }\n\n        this.animationFrame = requestAnimationFrame(this.animate);\n    }\n\n    updateOptions(newOptions) {\n        const oldOptions = { ...this.options };\n        this.options = { ...this.options, ...newOptions };\n        \n        // Update snowflakes count if needed\n        if (newOptions.count !== undefined) {\n            const diff = newOptions.count - this.snowflakes.length;\n            \n            if (diff > 0) {\n                // Add more snowflakes\n                const currentLength = this.snowflakes.length;\n                for (let i = 0; i < diff; i++) {\n                    this.snowflakes[currentLength + i] = this.createSnowflake();\n                }\n            } else if (diff < 0) {\n                // Remove excess snowflakes\n                this.snowflakes.length = newOptions.count;\n            }\n        }\n\n        // Cache frequently accessed values\n        const { minRadius, maxRadius, minSpeed, maxSpeed, wind } = this.options;\n\n        // Update sizes and speeds if radius changes\n        if (newOptions.minRadius !== undefined || newOptions.maxRadius !== undefined) {\n            const oldRadiusRange = oldOptions.maxRadius - oldOptions.minRadius;\n            const newRadiusRange = maxRadius - minRadius;\n            \n            this.snowflakes.forEach(snowflake => {\n                // Keep the same relative size ratio when updating radius\n                const oldRadiusRatio = (snowflake.radius - oldOptions.minRadius) / oldRadiusRange;\n                \n                // Calculate new radius maintaining the same relative position in the range\n                snowflake.radius = minRadius + (oldRadiusRatio * newRadiusRange);\n                \n                // Update speed based on new radius\n                const radiusRatio = (snowflake.radius - minRadius) / newRadiusRange;\n                snowflake.speed = minSpeed + (maxSpeed - minSpeed) * radiusRatio;\n            });\n        }\n\n        // Update wind for all snowflakes if wind changes\n        if (newOptions.wind !== undefined) {\n            this.snowflakes.forEach(snowflake => {\n                snowflake.wind = wind;\n            });\n        }\n\n        // Update color for all snowflakes if color changes\n        if (newOptions.color !== undefined) {\n            this.snowflakes.forEach(snowflake => {\n                snowflake.color = this.options.color;\n            });\n        }\n    }\n}\n\nexport default SnowfallCanvas;"],"names":["Snowflake","constructor","x","y","radius","speed","wind","color","this","initialX","initialRadius","initialSpeed","isReset","update","canvasHeight","draw","ctx","beginPath","arc","fillStyle","fill","reset","canvas","options","resizeTimeout","getContext","alpha","count","minRadius","maxRadius","minSpeed","maxSpeed","opacity","snowflakes","Array","isRunning","animationFrame","lastTime","frameInterval","animate","bind","resize","init","window","addEventListener","clearTimeout","setTimeout","width","forEach","snowflake","Math","random","height","i","createSnowflake","offsetWidth","offsetHeight","start","performance","now","stop","cancelAnimationFrame","currentTime","elapsed","requestAnimationFrame","clearRect","length","radiusRatio","updateOptions","newOptions","oldOptions","undefined","diff","currentLength","oldRadiusRange","newRadiusRange","oldRadiusRatio"],"mappings":"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"}