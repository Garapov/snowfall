{"version":3,"file":"snowfall.min.js","sources":["../src/snowflake.js","../src/index.js"],"sourcesContent":["export class Snowflake {\n    constructor(x, y, radius, speed, wind, color = 'white') {\n        // Store initial properties for reuse\n        this.initialX = x;\n        this.initialRadius = radius;\n        this.initialSpeed = speed;\n        this.color = color;\n        \n        // Current state\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.speed = speed;\n        this.wind = wind;\n        this.isReset = false;\n    }\n\n    update(canvasHeight, wind) {\n        this.y += this.speed;\n        this.x += wind;\n\n        // Simple bounds check\n        this.isReset = this.y > canvasHeight + this.radius * 2;\n    }\n\n    draw(ctx) {\n        // Skip drawing if offscreen\n        if (this.y < -this.radius * 2) return;\n        \n        // Use optimized circle drawing\n        ctx.beginPath();\n        ctx.arc(this.x | 0, this.y | 0, this.radius, 0, 6.283); // 6.283 â‰ˆ 2 * Math.PI, avoid calculation\n        ctx.fillStyle = this.color;\n        ctx.fill();\n    }\n\n    reset(x, y) {\n        this.x = x;\n        this.y = y;\n        this.isReset = false;\n    }\n}","import { Snowflake } from './snowflake';\n\nclass SnowfallCanvas {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d', { alpha: true }); // Enable transparent background\n        \n        // Default options\n        this.options = {\n            count: options.count || 100,\n            minRadius: options.minRadius || 2,\n            maxRadius: options.maxRadius || 5,\n            minSpeed: options.minSpeed || 1,\n            maxSpeed: options.maxSpeed || 3,\n            wind: options.wind || 0,\n            color: options.color || 'white',\n            opacity: options.opacity || 0.8,\n            ...options\n        };\n\n        this.snowflakes = new Array(this.options.count); // Pre-allocate array\n        this.isRunning = false;\n        this.animationFrame = null;\n        this.lastTime = 0;\n        this.frameInterval = 1000 / 60; // Target 60 FPS\n\n        // Bind methods that are used in animation loop\n        this.animate = this.animate.bind(this);\n\n        // Initialize after setting canvas dimensions\n        this.resize();\n        this.init();\n\n        // Debounced resize handler\n        let resizeTimeout;\n        window.addEventListener('resize', () => {\n            if (resizeTimeout) clearTimeout(resizeTimeout);\n            resizeTimeout = setTimeout(() => {\n                this.resize();\n                // Redistribute snowflakes across the new canvas width\n                const width = this.canvas.width;\n                this.snowflakes.forEach(snowflake => {\n                    snowflake.x = Math.random() * width;\n                });\n            }, 150);\n        });\n    }\n\n    init() {\n        const { width, height } = this.canvas;\n        \n        // Create snowflakes in a single loop\n        for (let i = 0; i < this.options.count; i++) {\n            const x = Math.random() * width;\n            const y = Math.random() * height - height; // Start above the canvas\n            this.snowflakes[i] = this.createSnowflake(x, y);\n        }\n    }\n\n    createSnowflake(x = null, y = null) {\n        const { minRadius, maxRadius, minSpeed, maxSpeed, wind, color } = this.options;\n        \n        const radius = Math.random() * (maxRadius - minRadius) + minRadius;\n        // Calculate speed based on radius - bigger snowflakes fall faster\n        const radiusRatio = (radius - minRadius) / (maxRadius - minRadius);\n        const speed = minSpeed + (maxSpeed - minSpeed) * radiusRatio;\n        \n        x = x ?? Math.random() * this.canvas.width;\n        y = y ?? Math.random() * -this.canvas.height;\n\n        return new Snowflake(x, y, radius, speed, wind, color);\n    }\n\n    resize() {\n        const { offsetWidth, offsetHeight } = this.canvas;\n        this.canvas.width = offsetWidth;\n        this.canvas.height = offsetHeight;\n        \n        // Set constant properties\n        this.ctx.fillStyle = 'white';\n    }\n\n    start() {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            this.lastTime = performance.now();\n            this.animate();\n        }\n    }\n\n    stop() {\n        this.isRunning = false;\n        if (this.animationFrame) {\n            cancelAnimationFrame(this.animationFrame);\n            this.animationFrame = null;\n        }\n    }\n\n    animate(currentTime = 0) {\n        if (!this.isRunning) return;\n\n        // Control frame rate\n        const elapsed = currentTime - this.lastTime;\n        if (elapsed < this.frameInterval) {\n            this.animationFrame = requestAnimationFrame(this.animate);\n            return;\n        }\n        this.lastTime = currentTime - (elapsed % this.frameInterval);\n\n        const { width, height } = this.canvas;\n        const { wind } = this.options;\n        \n        this.ctx.clearRect(0, 0, width, height);\n        \n        // Update and draw in a single loop\n        for (let i = 0; i < this.snowflakes.length; i++) {\n            const snowflake = this.snowflakes[i];\n            snowflake.update(height, wind);\n            \n            if (snowflake.isReset) {\n                const x = Math.random() * width;\n                // When resetting, recalculate speed based on radius\n                const radiusRatio = (snowflake.radius - this.options.minRadius) / (this.options.maxRadius - this.options.minRadius);\n                snowflake.speed = this.options.minSpeed + (this.options.maxSpeed - this.options.minSpeed) * radiusRatio;\n                snowflake.wind = wind;\n                snowflake.reset(x, -10);\n            }\n            \n            snowflake.draw(this.ctx);\n        }\n\n        this.animationFrame = requestAnimationFrame(this.animate);\n    }\n\n    updateOptions(newOptions) {\n        const oldOptions = { ...this.options };\n        this.options = { ...this.options, ...newOptions };\n        \n        // Update snowflakes count if needed\n        if (newOptions.count !== undefined) {\n            const diff = newOptions.count - this.snowflakes.length;\n            \n            if (diff > 0) {\n                // Add more snowflakes\n                const currentLength = this.snowflakes.length;\n                for (let i = 0; i < diff; i++) {\n                    this.snowflakes[currentLength + i] = this.createSnowflake();\n                }\n            } else if (diff < 0) {\n                // Remove excess snowflakes\n                this.snowflakes.length = newOptions.count;\n            }\n        }\n\n        // Cache frequently accessed values\n        const { minRadius, maxRadius, minSpeed, maxSpeed, wind } = this.options;\n\n        // Update sizes and speeds if radius changes\n        if (newOptions.minRadius !== undefined || newOptions.maxRadius !== undefined) {\n            const oldRadiusRange = oldOptions.maxRadius - oldOptions.minRadius;\n            const newRadiusRange = maxRadius - minRadius;\n            \n            this.snowflakes.forEach(snowflake => {\n                // Keep the same relative size ratio when updating radius\n                const oldRadiusRatio = (snowflake.radius - oldOptions.minRadius) / oldRadiusRange;\n                \n                // Calculate new radius maintaining the same relative position in the range\n                snowflake.radius = minRadius + (oldRadiusRatio * newRadiusRange);\n                \n                // Update speed based on new radius\n                const radiusRatio = (snowflake.radius - minRadius) / newRadiusRange;\n                snowflake.speed = minSpeed + (maxSpeed - minSpeed) * radiusRatio;\n            });\n        }\n\n        // Update wind for all snowflakes if wind changes\n        if (newOptions.wind !== undefined) {\n            this.snowflakes.forEach(snowflake => {\n                snowflake.wind = wind;\n            });\n        }\n\n        // Update color for all snowflakes if color changes\n        if (newOptions.color !== undefined) {\n            this.snowflakes.forEach(snowflake => {\n                snowflake.color = this.options.color;\n            });\n        }\n    }\n}\n\nexport default SnowfallCanvas;"],"names":["Snowflake","constructor","x","y","radius","speed","wind","color","this","initialX","initialRadius","initialSpeed","isReset","update","canvasHeight","draw","ctx","beginPath","arc","fillStyle","fill","reset","SnowfallCanvas","canvas","options","resizeTimeout","getContext","alpha","count","minRadius","maxRadius","minSpeed","maxSpeed","opacity","snowflakes","Array","isRunning","animationFrame","lastTime","frameInterval","animate","bind","resize","init","window","addEventListener","clearTimeout","setTimeout","width","forEach","snowflake","Math","random","height","i","createSnowflake","offsetWidth","offsetHeight","start","performance","now","stop","cancelAnimationFrame","currentTime","elapsed","requestAnimationFrame","clearRect","length","radiusRatio","updateOptions","newOptions","oldOptions","undefined","diff","currentLength","oldRadiusRange","newRadiusRange","oldRadiusRatio"],"mappings":"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"}